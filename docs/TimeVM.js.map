{"version":3,"file":"TimeVM.js","sources":["../src/utils.js","../src/process.js","../src/commands.js","../src/vm.js","../src/gibberish.js","../src/ext/random.js","../src/ext/debug.js","../src/index.js"],"sourcesContent":["// # TimeVM utilities\n\n// test if an object is an array\nexport const isArray = Array.isArray;\n\n// test if an object is a string\nexport const isString = o => typeof o === \"string\";\n\n// get last element from an array\nexport const last = (a) => a[a.length - 1];\n\n// A modulo operation that handles negative n more appropriately\n// e.g. wrap(-1, 3) returns 2\n// see http://en.wikipedia.org/wiki/Modulo_operation\n// see also http://jsperf.com/modulo-for-negative-numbers\nexport const wrap = (a, b) => (a % b + b) % b;\n","// # Process\n\nconst isCommand = o => typeof o === \"string\" && o[0] === \"@\";\nconst isProgram = Array.isArray;\nlet procId = 1;\nconst ERR_INSTR_NOT_FOUND = \"Instruction not recognized.\";\n\n// Processes are the principal computation unit. It departures from typical\n// processes in that it model the concept of time\nexport class Process {\n  constructor(program, context, time, rate) {\n    this.id = \"proc-\" + procId++;\n    // a stack of values\n    this.stack = [];\n    // the instructions are stored in a stack (in reverse order)\n    this.instructions = program ? [program] : [];\n    // the context is used to store variables with scope\n    this.context = new Context(context);\n    // the current time\n    this.time = typeof time === \"number\" ? time : 0;\n    // how fast time passes\n    this.rate = typeof rate === \"number\" ? rate : 1;\n    // bind error to allow destructuring in commands\n    this.error = this.error.bind(this)\n  }\n\n  // wait an amount of time\n  wait(time) {\n    this.time += this.rate * time;\n  }\n\n  // The process is agnostic about the commands to be use\n  step(commands) {\n    const { instructions } = this;\n    if (instructions.length) {\n      const instr = instructions.pop();\n      if (instr === null || instr === undefined) {\n        // ignore\n      } else if (typeof instruction === \"function\") {\n        instruction();\n      } else if (isProgram(instr)) {\n        // if it's program, and since the instructions are stored into an stack,\n        // we need add to the program instructions in reverse order\n        for (let i = instr.length - 1; i >= 0; i--) {\n          instructions.push(instr[i]);\n        }\n      } else if (isCommand(instr)) {\n        const operation = commands[instr];\n        if (typeof operation === \"function\") operation(this);\n        else this.error(\"\", ERR_INSTR_NOT_FOUND, instr);\n      } else {\n        // if it's a value, push it into the stack\n        this.stack.push(instr);\n      }\n    }\n  }\n\n  // the `resume` function run all the instructions until time is reached\n  resume(commands, time = Infinity, limit = 10000) {\n    const { instructions } = this;\n    while (--limit > 0 && this.time < time && instructions.length) {\n      this.step(commands);\n    }\n    if (limit === 0) this.error(\"Resume\", ERR_LIMIT_REACHED);\n    return instructions.length > 0;\n  }\n\n  // an utility function to write errors\n  error(instr, msg, obj) {\n    console.error(instr, msg, obj, \"id\", this.id, \"time\", this.time);\n  }\n}\n\n// ## Context\n\n// A context is a hierarchical structure to store values with scope\nexport class Context {\n  constructor(parent) {\n    if (parent instanceof Context) this.parent = parent;\n    else if (parent) this.local = Object.assign({}, parent);\n  }\n  // get a value from a context\n  get(id) {\n    let target = this;\n    while (target.value(id) === undefined && target.parent) {\n      target = target.parent;\n    }\n    return target.value(id);\n  }\n\n  // set a value from a context\n  set(id, value) {\n    let target = this;\n    while (target.value(id) === undefined && target.parent) {\n      target = target.parent;\n    }\n    target.let(id, value);\n  }\n  // get a value from the local scope of a context\n  value(id) {\n    return this.local ? this.local[id] : undefined;\n  }\n\n  // set a value into the local scope of a context\n  let(id, value) {\n    if (!this.local) this.local = {};\n    this.local[id] = value;\n  }\n}\n","// # Commands\nimport { isArray, isString, last, wrap } from \"./utils\";\n\n// **Error messages**\nconst ERR_BAD_PATTERN = \"Expected a pattern, but found:\";\nconst ERR_LIMIT_REACHED = \"Limit reached. Probably an infinity loop.\";\n\n// **Utilities**\n\n// A generic stack operation that pops one value and pushes on result\nconst op1 = fn =>\n  ({ stack }) => {\n    stack.push(fn(stack.pop()));\n  };\n\n// A generic stack operation that pops two values and pushes one result\nconst op2 = fn =>\n  ({ stack }) => {\n    stack.push(fn(stack.pop(), stack.pop()));\n  };\n\n// A commands object is a map from instrunction name to functions\nexport default {\n  // ## Arithmetic\n  // | Name | Description | Example |\n  // |------|-------------|---------|\n  // | **@+**, **@add** | Add two values | `[1, 2, \"@+\"]` |\n  // | **@-**, **@sub** | Subtract two values | `[2, 1, \"@-\"]` |\n  // | **@\\***, **@mul** | Multiply two values | `[2, 4, \"@*\"]` |\n  // | **@/**, **@div** | Divide two values | `[4, 2, \"@*\"]` |\n  // | **@%**, **@wrap** | Modulo for positive and negative numbers | `[4, -2, \"@%\"]` |\n  // | **@mod* | Standard modulo operation | `[4, 2, \"@mod\"]` |\n  // | **@neg* | The negative of a value | `[4, \"@neg\"]` |\n  // [1, 2, \"@+\"]\n  \"@+\": op2((b, a) => a + b),\n  // [1, 2, \"@add\"]\n  \"@add\": \"@+\",\n  // [2, 1, \"@-\"]\n  \"@-\": op2((b, a) => a - b),\n  // [2, 1, \"@sub\"]\n  \"@sub\": \"@-\",\n  \"@*\": op2((b, a) => a * b),\n  \"@mul\": \"@*\",\n  \"@/\": op2((b, a) => b === 0 ? 0 : a / b),\n  \"@div\": \"@/\",\n  \"@%\": op2((b, a) => b === 0 ? 0 : wrap(a, b)),\n  \"@wrap\": \"@%\",\n  \"@mod\": op2((b, a) => b === 0 ? 0 : a % b),\n  \"@neg\": op1(a => -a),\n\n  // ## Logic\n\n  \"@cond\": ({ stack, instructions }) => {\n    const test = stack.pop();\n    // this is the pattern to execute if the test passes\n    const success = instructions.pop();\n    // the next pattern is the \"else\" part\n    if (test) {\n      // remove the \"else\" part\n      instructions.pop();\n      instructions.push(success);\n    }\n  },\n  \"@>\": op2((b, a) => a > b),\n  \"@>=\": op2((b, a) => a >= b),\n  \"@<\": op2((b, a) => a < b),\n  \"@<=\": op2((b, a) => a <= b),\n  \"@==\": op2((b, a) => a === b),\n  \"@!=\": op2((b, a) => a !== b),\n  \"@!\": op1(a => !a),\n  \"@not\": \"@!\",\n  \"@&&\": op2((b, a) => a && b),\n  \"@and\": \"@&&\",\n  \"@||\": op2((b, a) => a || b),\n  \"@or\": \"@||\",\n\n  // ## Core\n\n  // This are the core operations: execute instructions, modify\n  // process time and context variables\n\n  // | Name | Description | Example |\n  // |------|-------------|---------|\n  // | **@** | Alias of @execute | `10,'dup','@'` |\n  // | **@let** | Assign a value to the local context | `10,'repetitions',@let` |\n  // | **@set** | Assign a value to the global context | `10,'parts',@set` |\n  // | **@get** | Push the value of a variable into the stack | `'repetitions',@get` |\n  // | **@wait** | Wait an amount of time | `1,@wait` |\n  // | **@sync** | Wait until next beat | `@sync` |\n\n  // ## Process\n\n  // Operation related to interact with the current process\n\n  \"@let\": ({ stack, context }) => context.let(stack.pop(), stack.pop()),\n  \"@set\": ({ stack, context }) => context.set(stack.pop(), stack.pop()),\n  \"@get\": ({ stack, context }) => stack.push(context.get(stack.pop())),\n\n  \"@wait\": proc => proc.wait(Math.abs(Number(proc.stack.pop()))),\n  \"@sync\": proc => proc.wait(Math.floor(proc.time) + 1 - proc.time),\n\n  // ## Execute and repeat\n\n  // | Name | Description | Example |\n  // |------|-------------|---------|\n  // | **@dup** | Duplicate item (so you can use it twice) | `10,@dup` |\n  // | **@execute** | Execute an instruction | `10,'dup','@execute'` |\n  // | **@repeat** | Repeat | `4, \"@repeat\", [\"@kick\", 0.5, \"@wait\"]` |\n  // | **@forever** | Repeat forever | `\"@forever\", [\"@kick\", 0.5, \"@wait\"]` |\n  \"@dup\": ({ stack }) => stack.push(last(stack)),\n  \"@execute\": ({ instructions, error }) => {\n    const instr = instructions.pop();\n    if (isString(instr)) instructions.push(\"@instr\");\n    else error(\"@execute\", ERR_EXPECT_STRING, instr);\n  },\n  \"@\": \"@execute\",\n  \"@repeat\": ({ stack, instructions }) => {\n    const repetitions = stack.pop();\n    const pattern = last(instructions);\n    if (!isArray(pattern)) throw Error(\"Can't repeat: \" + pattern);\n    for (let i = 1; i < repetitions; i++) {\n      instructions.push(pattern);\n    }\n  },\n  \"@forever\": ({ instructions }) => {\n    const pattern = last(instructions);\n    if (!isArray(pattern)) throw Error(\"Can't forover: \" + pattern);\n    if (pattern.length) {\n      instructions.push(\"@forever\");\n      instructions.push(pattern);\n    }\n  },\n\n  // ## Iteration and lists\n  // | Name | Description | Example |\n  // |------|-------------|---------|\n  // | **@iter** | Iterate a pattern | `[[\"@iter\", [0.3, 1]], \"amp\", \"@set\"]` |\n  \"@iter\": ({ instructions, error }) => {\n    const pattern = instructions.pop();\n    if (!isArray(pattern) || !pattern.length)\n      error(\"@iter\", ERR_BAD_PATTERN, pattern);\n    else {\n      // Rotates the pattern and plays the first item only each time\n      // remove '1st' item, schedule, then push to back:\n      const first = pattern.splice(0, 1);\n      instructions.push(first);\n      pattern.push(first);\n    }\n  },\n\n};\n\n// Given a commands object, expand the aliases\nexport function expandAliases(commands) {\n  Object.keys(commands).forEach(name => {\n    const op = commands[name];\n    if (isString(op)) commands[name] = commands[op];\n  });\n  return commands;\n}\n","// # VM\n\nimport { isArray, isString } from \"./utils\";\nimport { Process, Context } from \"./process\";\nimport stdlib, { expandAliases } from \"./commands\";\n\nconst assign = Object.assign;\n\n// The purpose of the VM is to run processes concurrently. It also\n// mantains an extensible object of commands (instructions mapped to functions)\n// that allows to add instructions to the vm\n\n// TODO: probably is better to have functions and object instead of classes\n// will change in the future\nexport class VM {\n  constructor() {\n    this.procs = []; // the procs are inverse ordered by time\n    this.procsByName = {}; // a map of names to procs\n    this.time = 0;\n    this.commands = createCommands(this);\n    this.addCommands(stdlib)\n  }\n\n  // Add more commands\n  addCommands(commands) {\n    assign(this.commands, expandAliases(commands));\n  }\n\n  // Create a new process\n  fork(name, parent, program, delay = 0, rate) {\n    const time = this.time + delay;\n    // if has parent and no rate, try to use it's rate\n    if (!rate && parent) rate = parent.rate;\n    // if has parent try to use it's context\n    const context = parent ? parent.context || parent : undefined;\n    // create the new process and insert into the process stack\n    const proc = new Process(program, context, time, rate);\n    insert(proc, this.procs);\n    // if has name, register it\n    if (name) this.procsByName[name] = proc;\n    return proc;\n  }\n\n  // run the vm for the given amount of time (Infinity if not specified)\n  resume(dur = Infinity, limit = 10000) {\n    const { procs } = this;\n    if (procs.length === 0) return false;\n    const time = this.time + dur;\n    while (--limit > 0 && at(procs) < time) {\n      const proc = procs.pop();\n      if (proc.resume(this.commands, time)) {\n        // the proc has more operations, re-schedule\n        insert(proc, this.procs);\n      }\n    }\n    this.time = time;\n    return procs.length > 0;\n  }\n\n  stopAll() {\n    this.procs.length = 0;\n  }\n\n  // The stop function can stop a proccess by name or by object\n  stop(proc) {\n    if (typeof proc === \"string\") {\n      const name = proc;\n      proc = this.procsByName[name];\n      this.procsByName[name] = null;\n    }\n    remove(proc, this.procs);\n  }\n}\n\n// ## VM commands\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@fork** | Fork | `@fork, [0.5, \"@wait\", \"@kick\"]` |\n// | **@spawn** | Spawn | `\"melody\", \"@spawn\", [0.5, \"@wait\", \"@kick\"]` |\n// | **@stop** | Stop current process | `@stop` |\n// | **@stop-all** | Stop all processes | `@stop-all` |\nfunction createCommands(vm) {\n  return {\n    \"@loop\": proc => {\n      const { instructions, error } = proc;\n      const pattern = instructions.pop();\n      if (isArray(pattern)) vm.fork(null, proc, [\"@forever\", pattern]);\n      else error(\"@loop\", ERR_BAD_PATTERN, pattern);\n    },\n    \"@fork\": proc => {\n      const { instructions, error } = proc;\n      let pattern = instructions.pop();\n\n      if (isArray(pattern)) {\n        vm.fork(null, proc, pattern);\n      } else {\n        error(\"@fork\", ERR_BAD_PATTERN, pattern);\n      }\n    },\n    \"@spawn\": proc => {\n      const { stack, instructions, error } = proc;\n      const name = stack.pop();\n      let pattern = instructions.pop();\n      if (!isString(name)) {\n        error(\"@spawn\", ERR_NAME, name);\n      } else if (!isArray(pattern)) {\n        error(\"@spawn\", ERR_BAD_PATTERN, pattern);\n      } else {\n        vm.stop(name);\n        vm.fork(name, proc, [\"@forever\", pattern]);\n      }\n    },\n    \"@stop-all\": proc => vm.stopAll()\n  };\n}\n\n// ## Internal VM functions\n\n// remove a process process\nfunction remove(proc, procs) {\n  let i = procs.length - 1;\n  while (i >= 0 && procs[i] !== proc)\n    i--;\n  // if found, remove it\n  if (i !== -1) procs.splice(i, 1);\n}\n\n// insert a process into a stack ordered by time\n// (in fact, is inverse order because it's a stack)\nfunction insert(proc, procs) {\n  if (procs.length === 0) {\n    // no need to sort: just push it\n    procs.push(proc);\n  } else {\n    // procs are sorted on insertion\n    let i = procs.length - 1;\n    let p = procs[i];\n    while (p && p.time <= proc.time) {\n      i--;\n      p = procs[i];\n    }\n    procs.splice(i + 1, 0, proc);\n  }\n  return proc;\n}\n\n// get time of the next process\nfunction at(procs) {\n  const len = procs.length;\n  return len ? procs[len - 1].time : Infinity;\n}\n","let bpm = 100;\nlet sampleRate = null;\nlet bpm2bpa = null;\nlet vms = [];\nlet instruments = null;\nlet commands = null;\n\nconst instrumentCmds = {\n  \"@pluck\": ({ stack }, { note }) => note(\"\")\n};\n\nexport function gibberish(Gibberish, vm) {\n  if (arguments.length === 1) return vm => gibberish(Gibberish, vm);\n  if (sampleRate === null) initAudio()\n\n  vms.push(vm);\n  vm.addCommands(commands)\n  return Gibberish;\n}\n\nfunction initAudio () {\n  Gibberish.init();\n  sampleRate = Gibberish.context.sampleRate;\n  bpm2bpa = 1 / (60 * sampleRate);\n  instruments = createInstruments(Gibberish, instConfig);\n  commands = createCommands(instruments, cmdConfig);\n  Gibberish.sequencers.push(sequencer);\n\n}\n\n// The Gibberish sequencer that controlls all\nconst sequencer = {\n  tick() {\n    const len = vms.length;\n    if (len === 0) return;\n    const dur = bpm * bpm2bpa;\n    for (let i = 0; i < len; i++) {\n      vms[i].resume(dur);\n    }\n  }\n};\n\n// This is the instruments configuration\nconst instConfig = [\n  [\"kick\", \"Kick\", { decay: 0.2 }],\n  [\"snare\", \"Snare\", { snappy: 1.5 }],\n  [\"hat\", \"Hat\", { amp: 1.5 }],\n  [\"conga\", \"Conga\", { amp: 0.25, freq: 400 }],\n  [\"tom\", \"Tom\", { amp: 0.25, freq: 400 }],\n  [\"pluck\", \"PolyKarplusStrong\", { maxVoices: 32 }],\n  [\n    \"bass\",\n    \"MonoSynth\",\n    {\n      attack: 44,\n      decay: 0.25, // FIXME(danigb) -- it was: Gibberish.Time.beats(0.25),\n      filterMult: 0.25,\n      octave2: 0,\n      octave3: 0\n    }\n  ]\n];\n// Given a instruments configuration, create the Giberish instruments\nfunction createInstruments(G, config) {\n  return config.reduce(\n    (insts, [name, type, params]) => {\n      insts[name] = new G[type](params).connect();\n      return insts;\n    },\n    {}\n  );\n}\n\n// ## Commands\n\n// A trigger function receives the instrument and the parameters\nconst tr1 = (inst, amp) => {\n  inst.amp = amp\n  inst.note()\n}\n// trigger an instrument with 2 params\nconst tr2 = (inst, amp, freq) => {\n  inst.amp = amp\n  inst.freq = freq\n  inst.note()\n}\n// the bass is only triggered if the frequency is positive\n// the bass is only triggered if the frequency is positive\nconst trBass = (bass, amp, freq) => {\n  if (freq > 0) bass.note(amp, freq);\n};\n// trigger the pluck requires adjust dump and compensate volume\nconst trPluck = (strings, amp, freq) => {\n  if (freq > 0) {\n    // This is not in any way accurate, just a hack to make @set-dur do something semi-meaningful\n    strings.damping = 1 - -6 / Math.log(freq / sampleRate);\n    // Strings by default seem too quiet:\n    strings.note(freq, amp * amp * 2);\n  }\n};\n\n// ## Instrument commands\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@pluck** | Trigger a string sound | `@pluck` |\n// | **@pluck-note** | Trigger a string sound passing parameters | `freq, amp, @pluck` |\n// | **@bass** | Trigger a bass sound | `@bass` |\n// | **@bass-note** | Trigger a bass sound passing parameters | `freq, amp, @bass` |\nconst cmdConfig = {\n  pluck: [\"amp\", \"freq\", trPluck],\n  bass: [\"amp\", \"freq\", trBass],\n  kick: [\"amp\", null, tr1],\n  snare: [\"amp\", null, tr1],\n  hat: [\"amp\", null, tr1],\n  conga: [\"amp\", \"freq\", tr2],\n  tom: [\"amp\", \"freq\", tr2]\n};\n\nfunction createCommands(instruments, config) {\n  return Object.keys(config).reduce(\n    (cmds, name) => {\n      const cmdConfig = config[name];\n      const inst = instruments[name];\n      cmds[\"@\" + name] = fromScope(inst, cmdConfig);\n      cmds[\"@\" + name + \"-note\"] = fromStack(inst, cmdConfig);\n      return cmds;\n    },\n    {}\n  );\n}\n\n// Create an instrument command that get the parameters from context\n// example: `['@pluck']`\nfunction fromScope(inst, [name1, name2, trigger]) {\n  return ({ context }) => trigger(inst, context.get(name1), context.get(name2));\n}\n\n// Create an instrument command that get the parameters from the stack\n// example: `[0.2, 05, '@pluck-note']`\nfunction fromStack(inst, [name1, name2, trigger]) {\n  return ({ stack }) =>\n    trigger(inst, stack.pop(), name2 ? stack.pop() : undefined);\n}\n","// ## Randomness\nimport { isArray } from '../utils'\nconst { floor } = Math\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@random** | Generate a random number between 0 and 1 | `[\"@random\", \"amp\", \"@set\"]` |\n// | **@rand** | Alias for @random | |\n// | **@srandom** | Generate a random number between -1 and 1 | `[\"@srandom\", \"phase\", \"@set\"]` |\n// | **@srand** | Alias for @srandom | |\n// | **@randi** | Generate a random integer between 0 and n | `[60, \"@randi\", \"midi\", \"@set\"]` |\n// | **@pick** | Pick a random element from a list | `[\"@pick\", [1, 2, 3, 4]]` |\n// | **@chance** | Probabilistic execution | `probability, \"@chance\", executed-if-true, executed-if-false` |\nexport default function random(random) {\n  // allow to use a custom random function\n  const rnd = random || Math.random;\n  // a function that generates integer random from 0 to n\n  const irnd = n => floor(rnd() * n);\n\n  return {\n    \"@random\": ({ stack }) => stack.push(rnd()),\n    \"@rand\": \"@random\",\n    \"@srandom\": ({ stack }) => stack.push(rnd() * 2 - 1),\n    \"@srand\": \"@srandom\",\n    \"@randi\": ({ stack }) => stack.push(irnd(stack.pop())),\n    \"@pick\": proc => {\n      const { stack, instructions, error } = proc;\n      const pattern = instructions.pop();\n      if (!isArray(pattern)) {\n        instructions.push(pattern);\n        error(\"Can't pick an element if is not an array\", pattern);\n      } else {\n        const i = irnd(pattern.length);\n        instructions.push(pattern[i]);\n      }\n    },\n    \"@chance\": ({ stack, instructions }) => {\n      const prob = stack.pop();\n      const pattern = instructions.pop();\n      if (rnd() < prob) {\n        // Skip item after\n        instructions.pop();\n        // Push the pattern\n        instructions.push(pattern);\n      }\n    }\n  };\n}\n","// # Debug operations\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@print** | Print the last value of the stack | `10,\"@print\"` |\n// | **@log** | Log the name with the last value of the stack | `\"@random\", \"amp\", \"@log\"` |\nexport default function debug(log) {\n  log = log || console.log.bind(console)\n\n  return {\n    \"@print\": (proc) => {\n      const { stack } = proc;\n      const last = stack.length ? last(stack) : \"<Empty Stack>\";\n      log(\"@print\", last, \"(id, time)\", proc.id, proc.time);\n    },\n    \"@log\": (proc) => {\n      const { stack } = proc;\n      const name = stack.pop();\n      const last = stack.length ? last(stack) : \"<Empty Stack>\";\n      log(\"@log\", name, last, \"(id, time)\", proc.id, proc.time);\n    },\n    \"@debug\": (proc) => {\n      const { stack } = proc;\n      log(\"@debug\", stack, proc.id, proc.time);\n    }\n  };\n}\n","// # Audio Virtual Machine\n\n// The main purpose of the virtual machine is to run processes concurrently\n\n// ## Architecture Overview\n\n// A **scheduler** is a collection of processes. Each **process** mantains\n// an internal time value that can be modified.\n\nimport { VM } from \"./vm\";\nimport { gibberish } from \"./gibberish\";\nimport random from './ext/random'\nimport debug from './ext/debug'\n\nconst INITIAL_CTX = { amp: 0.5, freq: 440 };\nconst newCtx = () => Object.assign({}, INITIAL_CTX)\n\n// ## API\n\nexport function init(Gibberish, ...plugins) {\n  // Create the virtual machine and setup commands\n  const vm = new VM();\n  vm.addCommands(random())\n  vm.addCommands(debug())\n  plugins.forEach(cmds => vm.addCommands(cmds))\n\n  // Init the audio driver\n  gibberish(Gibberish, vm);\n\n  // Return a `run(program)` function\n  // this is the simplest API I can think. Probably will change.\n  return (prog, sync = true) => {\n    vm.fork(null, newCtx(), sync ? [\"@sync\", prog] : prog);\n  };\n}\n"],"names":["isArray","Array","isString","o","last","a","length","wrap","b","isCommand","isProgram","procId","ERR_INSTR_NOT_FOUND","Process","program","context","time","rate","id","stack","instructions","Context","error","bind","commands","instr","pop","undefined","instruction","i","push","operation","Infinity","limit","step","ERR_LIMIT_REACHED","msg","obj","parent","local","Object","assign","target","value","let","ERR_BAD_PATTERN","op1","fn","op2","test","success","set","get","proc","wait","Math","abs","Number","floor","ERR_EXPECT_STRING","repetitions","pattern","Error","first","splice","expandAliases","keys","forEach","op","name","VM","procs","procsByName","createCommands","addCommands","stdlib","delay","dur","at","resume","vm","fork","ERR_NAME","stop","stopAll","remove","insert","p","len","bpm","sampleRate","bpm2bpa","vms","instruments","gibberish","Gibberish","arguments","initAudio","init","createInstruments","instConfig","cmdConfig","sequencers","sequencer","decay","snappy","amp","freq","maxVoices","G","config","reduce","insts","type","params","connect","tr1","inst","note","tr2","trBass","bass","trPluck","strings","damping","log","cmds","fromScope","fromStack","name1","name2","trigger","random","rnd","irnd","n","prob","debug","console","INITIAL_CTX","newCtx","plugins","prog","sync"],"mappings":"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"}